Golang 101
--------------
Golang 101: Neden Go Ã–ÄŸrenmelisiniz ?
Bulut BiliÅŸimine ilgi duyuyorsanÄ±z Go dilini Ã¶ÄŸrenmeli ve yapÄ±sÄ±na hakim olmalÄ±sÄ±nÄ±z.

Go dilinde yazÄ±lan uygulamalar oldukÃ§a Ã§eÅŸitlidir ve Ã¶zellikle sistem programlama, aÄŸ programlama, web geliÅŸtirme ve veritabanÄ± programlama gibi alanlarda sÄ±kÃ§a kullanÄ±lmaktadÄ±r. Ã–rneÄŸin:

Docker: Docker, konteyner tabanlÄ± uygulama daÄŸÄ±tÄ±mÄ± iÃ§in popÃ¼ler bir platformdur ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

Kubernetes: Kubernetes, konteyner orkestrasyonu iÃ§in popÃ¼ler bir aÃ§Ä±k kaynaklÄ± platformdur ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

Etcd: Etcd, daÄŸÄ±tÄ±k key-value maÄŸazasÄ± olarak kullanÄ±lan bir veritabanÄ±dÄ±r ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

Hugo: Hugo, statik web siteleri oluÅŸturmak iÃ§in kullanÄ±lan aÃ§Ä±k kaynaklÄ± bir araÃ§tÄ±r ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

CockroachDB: CockroachDB, yÃ¼ksek Ã¶lÃ§eklenebilirlik saÄŸlayan daÄŸÄ±tÄ±k bir SQL veritabanÄ±dÄ±r ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

Prometheus: Prometheus, sistemlerin performans ve hata durumlarÄ±nÄ± izlemek iÃ§in kullanÄ±lan aÃ§Ä±k kaynaklÄ± bir araÃ§tÄ±r ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

InfluxDB: InfluxDB, zaman serisi verilerini depolamak ve sorgulamak iÃ§in kullanÄ±lan bir veritabanÄ±dÄ±r ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

Moby: Moby, Docker'Ä±n altÄ±nda yatan bileÅŸenleri iÃ§eren aÃ§Ä±k kaynaklÄ± bir proje ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

Caddy: Caddy, hafif bir HTTP sunucusu ve ters proxydir ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

WireGuard: WireGuard, hÄ±zlÄ± ve modern bir sanal Ã¶zel aÄŸ (VPN) Ã§Ã¶zÃ¼mÃ¼dÃ¼r ve Go dilinde yazÄ±lmÄ±ÅŸtÄ±r.

Minio:Minio Go dili ile yazÄ±lmÄ±ÅŸ ve sektÃ¶rde dosya yÃ¼kleme, saklama, getirme iÅŸlemlerinde standart hale gelmiÅŸ S3 API'larÄ± ile uyumlu Ã§alÄ±ÅŸan bir servis olarak yer almaktadÄ±r.

Bu, sadece Go dilinde yazÄ±lmÄ±ÅŸ bazÄ± popÃ¼ler uygulamalarÄ±n Ã¶rnekleri olup, Go dilinin diÄŸer alanlarda da kullanÄ±ldÄ±ÄŸÄ± unutulmamalÄ±dÄ±r.

Go Bulut BiliÅŸim iÃ§in Ã–nemli midir?
Go, Ã¶zellikle bulut biliÅŸim uygulamalarÄ± iÃ§in tasarlanmÄ±ÅŸ bir dil olduÄŸundan, hÄ±zlÄ±, verimli ve gÃ¼venilirdir. AyrÄ±ca Go, Ã§oklu iÅŸlem ve Ã§oklu iÅŸ parÃ§acÄ±ÄŸÄ± desteÄŸi sayesinde, yÃ¼ksek Ã¶lÃ§eklenebilirlik saÄŸlar.

Go dilinin bulut biliÅŸimdeki Ã¶nemi ÅŸu ÅŸekilde Ã¶zetlenebilir:

Verimlilik: Go dilinde yazÄ±lan uygulamalar, C dilinde yazÄ±lan uygulamalara kÄ±yasla daha hÄ±zlÄ± ve daha verimlidir. Bu, bulut biliÅŸim uygulamalarÄ±nÄ±n daha hÄ±zlÄ± ve daha dÃ¼ÅŸÃ¼k maliyetle Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar.

GÃ¼venilirlik: Go dilinde yazÄ±lan uygulamalar, gÃ¼venilirlikleriyle bilinirler. Go dilinin hatasÄ±z bellek yÃ¶netimi, hafÄ±za sÄ±zÄ±ntÄ±larÄ±na karÅŸÄ± koruma ve gÃ¼venlik Ã¶zellikleri, bulut biliÅŸim uygulamalarÄ± iÃ§in Ã¶nemlidir.

Ã–lÃ§eklenebilirlik: Go dilinde yazÄ±lan uygulamalar, Ã§oklu iÅŸlem ve Ã§oklu iÅŸ parÃ§acÄ±ÄŸÄ± desteÄŸi sayesinde yÃ¼ksek Ã¶lÃ§eklenebilirlik saÄŸlar. Bu, bulut biliÅŸim uygulamalarÄ±nÄ±n yÃ¼ksek trafik ve yÃ¼ksek iÅŸlem hacimleriyle baÅŸa Ã§Ä±kmasÄ±nÄ± saÄŸlar.

KolaylÄ±k: Go dilinde yazÄ±lan uygulamalar, yalÄ±n ve kolay anlaÅŸÄ±lÄ±r bir dil yapÄ±sÄ±na sahiptir. Bu, geliÅŸtiricilerin daha hÄ±zlÄ± ve daha kolay bir ÅŸekilde uygulama geliÅŸtirmelerini saÄŸlar.

Bu nedenlerden dolayÄ±, Go dilinin bulut biliÅŸimdeki yeri oldukÃ§a Ã¶nemlidir ve Ã¶zellikle bÃ¼yÃ¼k Ã¶lÃ§ekli bulut biliÅŸim uygulamalarÄ± iÃ§in tercih edilen bir dil haline gelmiÅŸtir.
Golang ile DeÄŸiÅŸken TanÄ±mlama
Bu senaryoda, Go programlama dilinde deÄŸiÅŸken tanÄ±mlamayÄ± Ã¶ÄŸreneceÄŸiz.

Go ile deÄŸiÅŸken tanÄ±mlamaya baÅŸlamadan Ã¶nce, Go paketini kurmamÄ±z gerekiyor.
apk add go

Ve bir dÃ¼zenleyici paketi,
apk add nano

Bu komut, Go ve nano paketini indirip kuracaktÄ±r.

Ä°lk Egzersiz
SayfalarÄ± oluÅŸturuken "Vim EditÃ¶rÃ¼" kullanacaÄŸÄ±z.
KÄ±sayollara hÄ±zlÄ± bir gÃ¶z atalÄ±m.
(Not: Bu adÄ±mda isterseniz yÃ¼klediÄŸimiz nano editÃ¶rÃ¼nÃ¼ de kullanabilirsiniz)

:q = EÄŸer yapÄ±lan deÄŸiÅŸiklikler kaydedilmiÅŸse Vim editÃ¶rÃ¼nÃ¼ kapatÄ±r. Aksi durumda uyarÄ± verecektir.

:q! = EditÃ¶rÃ¼ kaydetmeden direk olarak kapatÄ±r.

:w = YapÄ±lan deÄŸiÅŸiklikleri kaydeder.

:wq = YapÄ±lan deÄŸiÅŸiklikleri kaydeder ve Ã§Ä±kar.

ArdÄ±ndan vim editÃ¶rÃ¼nde "hello.go" adlÄ± ilk sayfayÄ± oluÅŸturalÄ±m.

vim hello.go
AÃ§Ä±lan sayfada iÅŸlem yapabilmek iÃ§in "i" harfine basarak "Insert Mode" u aktif hale getirelim ve sayfaya Ã§alÄ±ÅŸtÄ±rmak istediÄŸimiz kodu atalÄ±m.

Golang ile basit bir "Hello,World!" uygulamasÄ± yapalÄ±m

package main
import "fmt"
 
func main() {
    fmt.Println("Hello, World!")
    // Ä°ÅŸlemi kaydedip hello.go 'dan Ã§Ä±kmak iÃ§in "Esc" + ":" + "w" + "q" + "!" karakterlerine basÄ±p "enter" diyelim
}
ArdÄ±ndan hello.go sayfasÄ±nÄ± Ã§alÄ±ÅŸtÄ±ralÄ±m

go run hello.go
DoÄŸru Ã‡Ä±ktÄ± : Hello, World!

Not:EÄŸer bu adÄ±mda "bash: go: command not found" hatasÄ± aldÄ±ysanÄ±z,Go'yu yÃ¼klemeyi tekrar denemelisiniz.
Åimdi devam edebiliriz.
2. Egzersiz
Yeni bir sayfa oluÅŸturalÄ±m

variables.go

AÅŸaÄŸÄ±daki koda 1 deÄŸiÅŸken daha ekleyelim ve Ã§alÄ±ÅŸtÄ±ralÄ±m.

package main
import "fmt"

func main() {

	// `var` 1 veya 1 den fazla deÄŸiÅŸkeni tanÄ±mlar
	var a = "baÅŸlangÄ±Ã§ deÄŸeri "
	fmt.Println(a)

	// 1 seferde 1 den fazla deÄŸiÅŸken tanÄ±mlayabilirsiniz.
	var b, c int = 1, 2
	fmt.Println(b, c)

	// Go baÅŸlatÄ±lan deÄŸiÅŸkenlerin tipini algÄ±lar
	var d = true
	fmt.Println(d)

	// DeÄŸer atanmadan tanÄ±mlanan deÄŸiÅŸkenler 0 deÄŸerlidir
	var e int
	fmt.Println(e)

	// The `:=` syntax bir deÄŸiÅŸkene "initial" deÄŸeri vermek iÃ§in kullanÄ±lÄ±r
	var f string = "elma"
	fmt.Println(f)

    // AÅŸaÄŸÄ±da g deÄŸeri 10 olsun,fmt.Println() ile yukarÄ±daki Ã¶rnekler gibi bastÄ±rÄ±lsÄ±n

}
Ã‡alÄ±ÅŸtÄ±rmak iÃ§in,

go run variables.go
Ekranda deÄŸiÅŸkenlerin Ã§Ä±ktÄ±sÄ±nÄ± gÃ¶rÃ¼yorsak devam..
3. Egzersiz
Challenge Variables
Ekrana adÄ±nÄ±zÄ±,soyadÄ±nÄ±zÄ±,yaÅŸÄ±nÄ±zÄ± ve Ã¶ÄŸrenci olma durumunuzu yazdÄ±ran kodu yazÄ±nÄ±z.
ad -> string
soyad -> string
yaÅŸ -> integer
Ã¶ÄŸrenci mi-> boolean

Yeni bir sayfa oluÅŸturalÄ±m. File->New file
isim ->
variables2.go

Ã–rnek Kod:

package main
import "fmt"

func main() {
    age := 25
    name := "Alice"

    fmt.Println("Name:", name)
    fmt.Println("Age:", age)
}
Kodu yazalÄ±m, Ã‡alÄ±ÅŸtÄ±ralÄ±m

go run variables2.go
Ã‡Ä±ktÄ± dÃ¼zgÃ¼nse baÅŸardÄ±nÄ±z demektir,Golang de deÄŸiÅŸken tanÄ±mlamak bu kadar kolay :)
Hands-on Go Programlama : Golang Veri Tipleri Ã–ÄŸrenin
Bu senaryoda, Go dilinde veri tiplerini Ã¶ÄŸreneceksiniz:

dizi(array)
slice
map
struct
Ä°lk olarak ilgili paketleri yÃ¼kleyelim
apk add go

BaÅŸla butonuna tÄ±klayarak talimatlarla eÄŸitime baÅŸlayabilirsiniz
Go FonksiyonlarÄ±nÄ±n AnlaÅŸÄ±lmasÄ±: Kod Ã–rnekleri ile Bir GiriÅŸ
Go, Golang olarak da bilinen gÃ¼Ã§lÃ¼ ve verimli bir programlama dilidir ve basitliÄŸi ile eÅŸ zamanlÄ±lÄ±k Ã¶zellikleriyle tanÄ±nÄ±r. Go programlamasÄ±nÄ±n temel yapÄ± taÅŸlarÄ±ndan biri fonksiyon kavramÄ±dÄ±r. Bu makalede, Go fonksiyonlarÄ±nÄ±n Ã§eÅŸitli yÃ¶nlerini keÅŸfedecek ve kullanÄ±mlarÄ±nÄ± gÃ¶stermek iÃ§in kod Ã¶rnekleri sunacaÄŸÄ±z.

FonksiyonlarÄ±n TanÄ±mlanmasÄ± Go'da bir fonksiyon, belirli bir gÃ¶revi yerine getiren kod bloÄŸudur. Bu gÃ¶rev, programÄ±n farklÄ± bÃ¶lÃ¼mlerinden Ã§aÄŸrÄ±labilir. Bir fonksiyonun Go'da tanÄ±mlanma sÃ¶zdizimi aÅŸaÄŸÄ±daki gibidir:

func fonksiyonAdÄ±(parametre1 tip1, parametre2 tip2) dÃ¶nÃ¼ÅŸTipi {
    // Fonksiyon gÃ¶vdesi
    // Ã‡alÄ±ÅŸtÄ±rÄ±lacak kodlar
    return sonuÃ§
}
Bir Go fonksiyonunun bileÅŸenlerini inceleyelim:

func anahtar kelimesi: Fonksiyon tanÄ±mlamak iÃ§in kullanÄ±lÄ±r. fonksiyonAdÄ±: Bu, fonksiyonun tanÄ±mlayÄ±cÄ±sÄ±dÄ±r. Fonksiyonun amacÄ±nÄ± aÃ§Ä±klayan anlamlÄ± bir isim seÃ§ilmelidir. parametre1, parametre2: Bunlar fonksiyona giren parametrelerdir. Her parametre kendi tipini takip eder. dÃ¶nÃ¼ÅŸTipi: Fonksiyonun dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ deÄŸerin tipini temsil eder. EÄŸer fonksiyon herhangi bir deÄŸer dÃ¶ndÃ¼rmÃ¼yorsa, dÃ¶nÃ¼ÅŸTipi belirtilmez. return: Bu anahtar kelime, fonksiyondan bir deÄŸer dÃ¶ndÃ¼rmek iÃ§in kullanÄ±lÄ±r. Fonksiyonun dÃ¶nÃ¼ÅŸ tipi olmadÄ±ÄŸÄ± durumlarda return ifadesi opsiyoneldir.

Kod Ã–rneÄŸi 1: Basit Bir Toplama Fonksiyonu
Toplama iÅŸlemini gerÃ§ekleÅŸtiren basit bir fonksiyon Ã¶rneÄŸiyle baÅŸlayalÄ±m:

Ä°lk olarak,
main.go
adÄ±nda bir go dosyasÄ± oluÅŸturun
Kodu yazabilir ya da kopyalayabilirsiniz.

Not: Bu senaryoda tÃ¼m kodlarÄ± main.go iÃ§inde test ediniz.

package main

import (
	"fmt"
)

func sayilariTopla(a, b int) int {
    return a + b
}

func main() {
	toplam := sayilariTopla(10, 20)

	fmt.Println("Toplam: ", toplam)
}
Daha sonra test etmek iÃ§in
go run main.go
komutunu kullanÄ±n, test etmek istediÄŸiniz diÄŸer fonksiyonlar iÃ§in aynÄ± ÅŸekilde Ã§alÄ±ÅŸtÄ±rÄ±nÄ±z.

YukarÄ±daki kodda, iki tamsayÄ± a ve b parametreleri alan sayilariTopla adÄ±nda bir fonksiyon tanÄ±mlÄ±yoruz. Fonksiyon, a ve b deÄŸerlerinin toplamÄ±nÄ± tamsayÄ± olarak dÃ¶ndÃ¼rÃ¼yor. Kodu test edebilir ve devam edebilirsiniz
Kod Ã–rneÄŸi 3: DeÄŸiÅŸken SayÄ±da ArgÃ¼man Alan Fonksiyon
Go, fonksiyonlara ... sÃ¶zdizimi kullanarak deÄŸiÅŸken sayÄ±da argÃ¼man geÃ§me olanaÄŸÄ± tanÄ±r. Ä°ÅŸte birden fazla sayÄ±nÄ±n ortalamasÄ±nÄ± hesaplayan bir fonksiyon Ã¶rneÄŸi:

func ortalamaHesapla(sayilar ...float64) float64 {
    toplam := 0.0
    for _, sayi := range sayilar {
        toplam += sayi
    }
    return toplam / float64(len(sayilar))
}
YukarÄ±daki ortalamaHesapla fonksiyonunda, sayilar parametresi ... ile baÅŸlar, bu da onun deÄŸiÅŸken sayÄ±da ondalÄ±k sayÄ± argÃ¼manÄ±nÄ± kabul edebileceÄŸini belirtir. Fonksiyon, verilen tÃ¼m sayÄ±larÄ±n toplamÄ±nÄ± hesaplar ve ortalamasÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.

Bu fonksiyonu yazÄ±n ve test edin:

package main

import (
	"fmt"
)

func ortalamaHesapla(sayilar ...float64) float64 {
    toplam := 0.0
    for _, sayi := range sayilar {
        toplam += sayi
    }
    return toplam / float64(len(sayilar))
}

func main() {
	ortalama := ortalamaHesapla(10.5, 7.2, 4.8, 9.1, 6.6)

	fmt.Println("Ortalama: ", ortalama)
-------------------------------------------------------------------------
Pointers
Pointers, Go programlama dilinde bir deÄŸiÅŸkenin bellek adresini tutan bir deÄŸiÅŸkendir. Pointers sayesinde, iÅŸaret edilen deÄŸiÅŸkenin deÄŸerine dolaylÄ± olarak eriÅŸebilir ve deÄŸiÅŸtirebiliriz.

Pointer, bir deÄŸiÅŸkenin deÄŸerini bir fonksiyonda deÄŸiÅŸtirmemiz gerektiÄŸinde veya bÃ¼yÃ¼k miktarda veriyi fonksiyona kopyalamadan aktarmak istediÄŸimizde gibi birÃ§ok durumda faydalÄ±dÄ±r.

Bir Pointer deÄŸiÅŸkeni tanÄ±mladÄ±ÄŸÄ±mÄ±zda, iÅŸaret etmek istediÄŸimiz deÄŸiÅŸkenin tÃ¼rÃ¼nden Ã¶nce
*
operatÃ¶rÃ¼nÃ¼ kullanÄ±rÄ±z. Ã–rneÄŸin, var ptr
*int
, ptr adÄ±nda bir Pointers deÄŸiÅŸkeni tanÄ±mlar ve bu deÄŸiÅŸken bir tamsayÄ± deÄŸiÅŸkeninin bellek adresini tutabilir.

Ä°ÅŸaret edilen deÄŸiÅŸkenin deÄŸerine eriÅŸmek iÃ§in, Pointers deÄŸiÅŸkeninin Ã¶nÃ¼ne
*
operatÃ¶rÃ¼nÃ¼ kullanÄ±rÄ±z. Ã–rneÄŸin,
*ptr
, ptr tarafÄ±ndan iÅŸaret edilen tamsayÄ± deÄŸiÅŸkeninin deÄŸerini dÃ¶ndÃ¼rÃ¼r.

Pointers kullanarak iki tam sayÄ±nÄ±n yerini deÄŸiÅŸtirme
Bu senaryoda, Go dilinde pointer kullanarak iki tamsayÄ± deÄŸiÅŸkeninin deÄŸerlerinin nasÄ±l yer deÄŸiÅŸtirdiÄŸini gÃ¶steriyoruz. Ä°ki tamsayÄ± deÄŸiÅŸkeni tanÄ±mlar ve adreslerini,
*int
tÃ¼rÃ¼ndeki iki pointer argÃ¼manÄ± alan bir fonksiyona geÃ§iririz. Fonksiyon iÃ§inde, iki deÄŸiÅŸkenin deÄŸerlerini deÄŸiÅŸtirmek iÃ§in pointerlarÄ± kullanÄ±rÄ±z. Daha sonra, iki deÄŸiÅŸkenin adreslerini argÃ¼man olarak kullanarak fonksiyonu Ã§aÄŸÄ±rÄ±rÄ±z. Son olarak, deÄŸiÅŸkenlerin deÄŸerlerini yazdÄ±rarak yerlerinin deÄŸiÅŸip deÄŸiÅŸmediÄŸini doÄŸrularÄ±z.

File -> New File
swap.go

package main

import "fmt"

func swap(x *int, y *int) {
temp := *x
*x = *y
*y = temp
}

func main() {
a := 10
b := 20
fmt.Println("Before swap: a =", a, ", b =", b)
swap(&a, &b)
fmt.Println("After swap: a =", a, ", b =", b)
}
DosyanÄ±zÄ± swap.go adÄ±nda kaydedebilirsiniz, ve aÅŸaÄŸÄ±daki komut yardÄ±mÄ±yla Ã§alÄ±ÅŸtÄ±rarak Ã§Ä±ktÄ±sÄ±nÄ± gÃ¶zlemleyebilirsiniz.

go run swap.goÄ°nteger bir dizi iÃ§in bellekte dinamik olarak yer ayÄ±rma iÅŸlemi
Go dilinde pointer kullanarak bir integer dizisi iÃ§in bellekte dinamik olarak yer ayÄ±rmayÄ± nasÄ±l yapacaÄŸÄ±mÄ±zÄ± inceleyelim. Bir integer deÄŸiÅŸkeni tanÄ±mlÄ±yoruz ve deÄŸerini
*int
tÃ¼rÃ¼nde bir pointer deÄŸiÅŸkenine atÄ±yoruz. Daha sonra, make fonksiyonunu kullanarak integer dizisinin boyutunu integer deÄŸiÅŸkeni tarafÄ±ndan belirtilen bir bellek alanÄ± iÃ§in dinamik olarak ayÄ±rmaktayÄ±z.

Pointer deÄŸiÅŸkenine dizinin ilk Ã¶ÄŸesinin adresini atarÄ±z. DÃ¶ngÃ¼ kullanarak dizinin Ã¶ÄŸelerine deÄŸerler atarÄ±z. Son olarak, dizinin deÄŸerlerini yazdÄ±rarak atama iÅŸleminin doÄŸru bir ÅŸekilde yapÄ±ldÄ±ÄŸÄ±nÄ± onaylayabiliriz.

File -> New File
pointers.go

adlÄ± sayfayÄ± oluÅŸturalÄ±m.

package main

import "fmt"

func main() {
	size := 5
	ptr := new(*int)
	arr := make([]int, size)
	*ptr = &arr[0]

	for i := 0; i < size; i++ {
		arr[i] = i + 1
	}

	for i := 0; i < size; i++ {
		fmt.Println("arr[", i, "] =", arr[i])
	}

}
DosyanÄ±zÄ± pointers.go adÄ±nda kaydedebilirsiniz, ve aÅŸaÄŸÄ±daki komut yardÄ±mÄ±yla Ã§alÄ±ÅŸtÄ±rarak Ã§Ä±ktÄ±sÄ±nÄ± gÃ¶zlemleyebilirsiniz.

go run pointers.go
-------------------------------------------------------------------------------------------------------------------------

Go ile Concurrency(EÅŸzamanlÄ±lÄ±k) KavramlarÄ±
Go Dilindeki EÅŸzamanlÄ±lÄ±k, aynÄ± anda veya eÅŸzamanlÄ± olarak birden fazla gÃ¶revin yÃ¼rÃ¼tÃ¼lmesine olanak saÄŸlayan Go programlama dilinin bir programlama Ã¶zelliÄŸidir. Go'daki eÅŸzamanlÄ±lÄ±k gorutinler ve kanallar aracÄ±lÄ±ÄŸÄ±yla gerÃ§ekleÅŸtirilir.

gif2

BaÅŸla butonuna tÄ±klayarak talimatlarla eÄŸitime baÅŸlayabilirsiniz. ğŸš€
AdÄ±m 1: Go EÅŸzamanlÄ±lÄ±ÄŸÄ±nÄ± Anlama
Go, eÅŸzamanlÄ± programlama yapmayÄ± kolaylaÅŸtÄ±ran bir dildir ve aynÄ± anda birden fazla gÃ¶revi gerÃ§ekleÅŸtirmenize olanak tanÄ±r. Go'da, eÅŸzamanlÄ±lÄ±k, gorutinler ve kanallar kullanÄ±larak elde edilir.

Goroutin
Goroutin ler, Go Ã§alÄ±ÅŸma zamanÄ± tarafÄ±ndan yÃ¶netilen hafif iÅŸ parÃ§acÄ±klarÄ±dÄ±r. Her bir iÅŸlev iÃ§in yeni bir iÅŸ parÃ§acÄ±ÄŸÄ± oluÅŸturmadan fonksiyonlarÄ± aynÄ± anda yÃ¼rÃ¼tmeyi saÄŸlarlar. Gorutinler, arka planda belirtilen iÅŸlevi Ã§alÄ±ÅŸtÄ±ran go anahtar kelimesi kullanÄ±larak oluÅŸturulur.

Go paketini yÃ¼kleyelim.
apk add go

ArdÄ±ndan yeni bir Go sayfasÄ± oluÅŸturalÄ±m. dosya adÄ± ->
goroutine.go

Gorutin oluÅŸturmak iÃ§in bir iÅŸlev tanÄ±mlayabilir ve go anahtar kelimesini kullanarak baÅŸlatabilirsiniz:

package main
import "fmt"

func sayHello() {
    fmt.Println("Hello, world!")
}

func main() {
    go sayHello() // start a new goroutine
    fmt.Println("Main function")
}
Kodu Ã§alÄ±ÅŸtÄ±rÄ±ken ->
go run goroutine.go

"Hello, world!" mesajÄ±, Ã¶nceden baÅŸlatÄ±ldÄ±ÄŸÄ± halde "Main Function" mesajÄ±ndan sonra yazdÄ±rÄ±lmaktadÄ±r. Bu, sayHello fonksiyonunun arka planda eÅŸzamanlÄ± olarak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±yor olmasÄ± nedeniyledir.
Go Dilinde Dosya Ä°ÅŸlemleri: Kod Ã–rnekleri ile Bir GiriÅŸ
Go, Golang olarak da bilinen gÃ¼Ã§lÃ¼ ve verimli bir programlama dilidir ve kapsamlÄ± bir standart kÃ¼tÃ¼phane sunar. Bu kÃ¼tÃ¼phane iÃ§erisinde dosya iÅŸlemleri iÃ§in kapsamlÄ± destek bulunmaktadÄ±r. Bu senaryoda, Go dilinde dosya iÅŸlemlerinin temellerini keÅŸfedecek ve okuma, yazma ve dosyalarla Ã§alÄ±ÅŸma konusunda nasÄ±l kod Ã¶rnekleri kullanÄ±lacaÄŸÄ±nÄ± gÃ¶stereceÄŸiz.

DosyalarÄ±n AÃ§Ä±lmasÄ± ve OkunmasÄ±
Go dilinde, dosyalarÄ± aÃ§mak ve iÃ§eriÄŸini okumak iÃ§in os paketi kullanÄ±lÄ±r. os.Open() fonksiyonu bir dosyayÄ± aÃ§mak iÃ§in kullanÄ±lÄ±r ve ardÄ±ndan iÃ§eriÄŸi bir Reader ile okuyabilirsiniz.

Ä°lk olarak bir text dosyasÄ± oluÅŸturalÄ±m ->
ornek1.txt
Ä°Ã§ine
Bulut Bilisim 2023
yazalÄ±m

Go sayfasÄ± oluÅŸturun. AdÄ± ->
file.go

EditÃ¶re kodu yapÄ±ÅŸtÄ±rÄ±n ve "dosyaismi.txt" kÄ±smÄ±nÄ± yeniden isimlendirin->
sample.txt

package main

import (
    "fmt"
    "os"
)

func main() {
    dosya, hata := os.Open("dosyaismi.txt")
    if hata != nil {
        fmt.Println("Dosya aÃ§Ä±lÄ±rken hata oluÅŸtu:", hata)
        return
    }
    defer dosya.Close()

    veri := make([]byte, 100)
    sayac, hata := dosya.Read(veri)
    if hata != nil {
        fmt.Println("Dosya okunurken hata oluÅŸtu:", hata)
        return
    }

    fmt.Printf("Okunan %d byte: %s\n", sayac, veri[:sayac])
}
Kodu Ã§alÄ±ÅŸtÄ±ralÄ±m
go run file.go

Not: ilk adÄ±mda go yÃ¼klenmediyse bu adÄ±mda hata alÄ±rsÄ±nÄ±z.

YukarÄ±daki kodda, ornek.txt adlÄ± bir dosya aÃ§Ä±p, iÃ§eriÄŸini bir byte dizisine okutup, okunan veriyi ekrana yazdÄ±rdÄ±nÄ±z.

root ~/workspace $ go run hello.go
Okunan 18 byte: Bulut Bilisim 2023
Buna benzer bir Ã§Ä±ktÄ± aldÄ±ysanÄ±z, devam edebilirsiniz
Dosyalara Yazma
Go dilinde verileri dosyaya yazmak iÃ§in os.Create() fonksiyonu kullanÄ±lÄ±r. Bu fonksiyon, yeni bir dosya oluÅŸturur veya varolan bir dosyanÄ±n iÃ§eriÄŸini siler. Dosya elde edildiÄŸinde, verileri bir Writer ile yazabilirsiniz.

Bu adÄ±mda Create ile yeni bir metin dosyasÄ± oluÅŸturup iÃ§ine veri yazalÄ±m. Yeni bir go sayfasÄ±nÄ± oluÅŸturun ->
create.go

package main

import (
    "fmt"
    "os"
)

func main() {
    dosya, hata := os.Create("output.txt")
    if hata != nil {
        fmt.Println("Dosya oluÅŸturulurken hata oluÅŸtu:", hata)
        return
    }
    defer dosya.Close()

    icerik := "Merhaba, bu dosyaya yazÄ±ldÄ±!"
    _, hata = dosya.WriteString(icerik)
    if hata != nil {
        fmt.Println("Dosyaya yazÄ±lÄ±rken hata oluÅŸtu:", hata)
        return
    }

    fmt.Println("Veri baÅŸarÄ±yla dosyaya yazÄ±ldÄ±.")
}
Bu kodda, output.txt adÄ±nda yeni bir dosya oluÅŸturur ve iÃ§eriÄŸe "Merhaba, bu dosyaya yazÄ±ldÄ±!" yazÄ±sÄ±nÄ± yazar.

Bu Ã§Ä±ktÄ±yÄ± alÄ±yorsanÄ±z devam edebilirsiniz.

Dosya Ä°ÅŸlemleri ve DeÄŸiÅŸiklikler
Go dilinde dosya iÅŸlemleriyle ilgili baÅŸka birÃ§ok fonksiyon da bulunmaktadÄ±r, bunlar arasÄ±nda dosya adÄ±nÄ± deÄŸiÅŸtirme, dosya silme ve dosyanÄ±n var olup olmadÄ±ÄŸÄ±nÄ± kontrol etme gibi iÅŸlemler yer alÄ±r.
Son adÄ±mda bu iÅŸlemleri gerÃ§ekleÅŸtirelim.
Ä°lk olarak 1 text dosyasÄ±nÄ± oluÅŸturun ->
oldText.txt
,
iÃ§ine random yazÄ± yazÄ±p Ã§Ä±kÄ±n

Go sayfasÄ±nÄ± olÅŸturun ->
fileOperations.go

package main

import (
    "fmt"
    "os"
)

func main() {
    // Dosya adÄ±nÄ± deÄŸiÅŸtirme
    hata := os.Rename("oldText.txt", "newText.txt")
    if hata != nil {
        fmt.Println("Dosya adÄ± deÄŸiÅŸtirilirken hata oluÅŸtu:", hata)
        return
    }
}
go run fileOperations.go

newText.txt oluÅŸturulmuÅŸ mu kontrol edin ->
ls
komutu ile

Yeni go sayfasÄ±nÄ± olÅŸturun ->
fileOperations2.go

OluÅŸturduÄŸunuz yeni dosyayÄ± sildirin,

package main

import (
    "fmt"
    "os"
)

func main() {

    // Dosya silme
    hata := os.Remove("newText.txt")
    if hata != nil {
        fmt.Println("Dosya silinirken hata oluÅŸtu:", hata)
        return
    }

    // DosyanÄ±n var olup olmadÄ±ÄŸÄ±nÄ± kontrol etme
    if _, hata := os.Stat("newText.txt"); hata == nil {
        fmt.Println("Dosya mevcut.")
    } else {
        fmt.Println("Dosya mevcut deÄŸil.")
    }
}
go run fileOperations2.go

ls ile newText.txt dosyasÄ±nÄ±n artÄ±k olmadÄ±ÄŸÄ±nÄ± kontrol edin.

DosyayÄ± sildindiyse harika ilerleme gopher!, devam edebilirsin.
Matris Nedir?
Bir matris, sayÄ±larÄ±n satÄ±r ve sÃ¼tunlarda dÃ¼zenlendiÄŸi iki boyutlu bir dizidir. DoÄŸrusal cebirde kullanÄ±lan temel bir veri yapÄ±sÄ±dÄ±r ve Ã§eÅŸitli bilimsel ve matematiksel hesaplamalarda yaygÄ±n olarak kullanÄ±lÄ±r.

Go'da Matrislerle Ã‡alÄ±ÅŸmak
Go, matrislerle verimli bir ÅŸekilde Ã§alÄ±ÅŸmak iÃ§in Ã§eÅŸitli paketler ve kÃ¼tÃ¼phaneler saÄŸlar. PopÃ¼ler bir kÃ¼tÃ¼phane olan Gonum, sayÄ±sal hesaplamalar ve bilimsel hesaplama iÃ§in geniÅŸ iÅŸlevsellikler sunar.

Go sayfasÄ± oluÅŸturun. AdÄ±
matrix.go
olmalÄ±.

package main

import "fmt"

func main() {
    var i, j, rows, columns int

    var matrix [10][10]int
    var transposeMatrix [10][10]int

    fmt.Print("Matrisin satÄ±r ve sÃ¼tun sayÄ±sÄ±nÄ± girin = ")
    fmt.Scan(&rows, &columns)

    fmt.Println("Transpoze etmek iÃ§in Matris ElemanlarÄ±nÄ± Girin = ")
    for i = 0; i < rows; i++ {
        for j = 0; j < columns; j++ {
            fmt.Scan(&matrix[i][j])
        }
    }
    for i = 0; i < rows; i++ {
        for j = 0; j < columns; j++ {
            transposeMatrix[j][i] = matrix[i][j]
        }
    }
    fmt.Println("--- Transpoze Matris ElemanlarÄ± ---")
    for i = 0; i < columns; i++ {
        for j = 0; j < rows; j++ {
            fmt.Print(transposeMatrix[i][j], "  ")
        }
        fmt.Println()
    }
}
Bu komutu yazÄ±n
go run matrix.go

Ã‡Ä±ktÄ±nÄ±zÄ± kontrol edin. Bir sonraki adÄ±mda, toplama, Ã§Ä±karma ve Ã§arpma gibi matris iÅŸlemlerini keÅŸfedeceÄŸiz.

Bir sonraki adÄ±ma ilerleyiniz.

Matris Ä°ÅŸlemleri - Toplama ve Ã‡Ä±karma
Bu adÄ±mda, Go'da matrisler Ã¼zerinde toplama ve Ã§Ä±karma iÅŸlemlerini nasÄ±l gerÃ§ekleÅŸtireceÄŸimizi Ã¶ÄŸreneceÄŸiz.

Matris ile Toplama
Matris toplamasÄ±, iki matrisin karÅŸÄ±lÄ±k gelen elemanlarÄ±nÄ± birbirine ekleyerek gerÃ§ekleÅŸtirilir. Toplama iÅŸlemi yapÄ±labilmesi iÃ§in matrislerin aynÄ± boyutlarda olmasÄ± gerekmektedir.
matrix_addition.go
adÄ±nda yeni bir sayfa oluÅŸturun.

ArdÄ±ndan, aÅŸaÄŸÄ±daki kodu yapÄ±ÅŸtÄ±rÄ±n veya editor ile yazÄ±n:

package main

import "fmt"

func main() {
    var i, j, rows, columns int

    var firstMat [10][10]int
    var secondMat [10][10]int
	var sumMat [10][10]int

    fmt.Print("Matrisin satÄ±r ve sÃ¼tun sayÄ±sÄ±nÄ± girin = ")
    fmt.Scan(&rows, &columns)

    fmt.Println("Birinci Matris ElemanlarÄ±nÄ± Girin = ")
    for i = 0; i < rows; i++ {
        for j = 0; j < columns; j++ {
            fmt.Scan(&firstMat[i][j])
        }
    }
    fmt.Println("Ä°kinci Matris ElemanlarÄ±nÄ± Girin = ")
    for i = 0; i < rows; i++ {
        for j = 0; j < columns; j++ {
            fmt.Scan(&secondMat[i][j])
        }
    }
  	for i = 0; i < rows; i++ {
        for j = 0; j < columns; j++ {
            sumMat[i][j]=firstMat[i][j]+secondMat[i][j]
        }
    }
	for i = 0; i < rows; i++ {
        for j = 0; j < columns; j++ {
        	    fmt.Print(sumMat[i][j], "  ")
        }
        fmt.Println()        
	}    	
}
Then run the code

go run matrix_addition.go

Matris ile Ã‡Ä±karma
Matrislerde Ã§Ä±karma, bir matrisin elemanlarÄ±ndan diÄŸer matrisin karÅŸÄ±lÄ±k gelen elemanlarÄ± Ã§Ä±karÄ±larak gerÃ§ekleÅŸtirilir. Toplama iÅŸlemiyle olduÄŸu gibi, matrislerin aynÄ± boyutlarda olmasÄ± gerekmektedir.

Kodu matris toplama iÅŸlemini, Ã§Ä±karma iÅŸlemine Ã§evirin ve test edin. EÄŸer matrislerin toplamÄ±nÄ± ve Ã§Ä±karÄ±mÄ±nÄ± bulabiliyorsanÄ±z, devam edebilirsiniz...


Senaryo: Go Standard KÃ¼tÃ¼phanesini Kullanarak Basit Bir Web Sunucusu OluÅŸturma
Ä°lk olarak Go paketini yÃ¼kleyelim.

apk add go
Yeni bir dizin oluÅŸturun ve Go projeniz dizine gidin:
mkdir go-webserver && cd go-webserver
main.go adÄ±nda yeni bir dosya oluÅŸturun:
main.go

main.go dosyasÄ±nda, Go standart kÃ¼tÃ¼phanesinden net/http paketini iÃ§e aktarÄ±n ve gelen istekleri iÅŸleyecek bir handler fonksiyonu tanÄ±mlayÄ±n:

4.Belirli bir baÄŸlantÄ± noktasÄ±nda (bu durumda port 8080) sunucuyu baÅŸlatacak olan main fonksiyonunu tanÄ±mlayÄ±n:

package main

import (
    "fmt"
    "net/http"
)
func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}
main.go dosyasÄ±nÄ± kaydedin

main.go yu Ã§alÄ±ÅŸtÄ±ralÄ±m.

go run main.go
go_port_icon.PNG

Sol taraftaki navbarda bulunan porta git ikonu ile 8080 adresine giderek "Merhaba, DÃ¼nya!" mesajÄ±nÄ± tarayÄ±cÄ±nÄ±zda gÃ¶rÃ¼ntÃ¼leyin. Tebrikler, Go standart kÃ¼tÃ¼phanesi kullanarak basit bir web sunucusu baÅŸarÄ±yla oluÅŸturdunuz!
Go ie Test Yazma
Ä°lk Ã¶rnekte Golang kod tabanÄ±nÄ±zda, iki tamsayÄ± alÄ±p toplamÄ±nÄ± dÃ¶ndÃ¼ren basit bir fonksiyon mevcut. Bu fonksiyon iÃ§in birim testleri yazmak istiyorsunuz ve bÃ¶ylece fonksiyonun doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan emin olmak istiyorsunuz.

AynÄ± dizindeki fonksiyonunuzla birlikte function_test.go adÄ±nda yeni bir dosya oluÅŸturabilir ve Golang test paketini kullanarak fonksiyonunuzu test eden bir test fonksiyonu yazabilirsiniz.

ArdÄ±ndan yeni bir Go sayfasÄ± oluÅŸturalÄ±m.
File -> New file
main.go

Yeni sayfa oluÅŸturduktan sonra komut ekranÄ±na aÅŸaÄŸÄ±daki kodu ekleyelim.

// main.go
package main

import (
	"fmt"
)

func main() {
	result := sum(2, 3)
	fmt.Println("Result:", result)
}

func sum(a, b int) int {
	return a + b
}
ArdÄ±ndan yeni bir Go sayfasÄ± daha oluÅŸturalÄ±m.
File -> New file
main_test.go

// main_test.go
package main

import (
	"testing"
)

func TestSum(t *testing.T) {
	result := sum(2, 3)
	expected := 5
	if result != expected {
		t.Errorf("Expected %d, but got %d.", expected, result)
	}
}
KomutlarÄ± sÄ±rasÄ±yla Ã§alÄ±ÅŸtÄ±ralÄ±m

go mod init main.go

go mod tidy

Bu Ã¶rnekte, sum (toplam) fonksiyonunu test ediyoruz ve iki girdi iÃ§in doÄŸru deÄŸeri dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼nÃ¼ doÄŸrulayalÄ±m.

root ~/workspace $ go test
PASS
ok main.go 0.002s